\section{Implementation}
\subsection{Introduction}
In a previous version of the query language, code was generated for a DSM system
specified in \cite{285:Fischer2010}. While the introduced system had its 
limitations, extensions for this system were defined in \cite{297:Frey2010}. In 
particular, this included a XML schema for the code generator, operators in the 
framework and a message format for the DSM framework. This work provides a code 
generator for LUA which forms the foundation for the rewritten DSM framework for 
the DataStreamMiner project. It is a complete rewrite of the code generator of 
previous versions of the query language.

The remainder of this section is organized as follows. First, building blocks of 
the query language such as streams, barriers and operators and their 
corresponding LUA counterpart are presented. Second, deprecated features of the 
query language are discussed followed by the integration of knowledge 
representations into the query language. The section concludes with a short
summary.
\begin{center}
  \begin{tabular}{|l|l|l|l|}
  \hline 
  \textbf{Operator Flow} &  \textbf{Operator LUA} &  \textbf{Comment} \\
  \hline 
  \hline 
  \texttt{avg} & IntAvg, \textit{FloatAvg} & computes the average value \\
  \hline 
  \texttt{count} & MessageCounter & counts a element in a stream \\
  \hline 
  \texttt{std} & \textit{StandardDeviation} & computes standard deviation of a element \\
  \hline 
  \texttt{add} & \textit{Math} & addition operation \\
  \hline 
  \texttt{sub} & \textit{Math} & subtraction operation \\
  \hline 
  \texttt{mult} & \textit{Math} & multiplication operation \\
  \hline 
  \texttt{div} & \textit{Math} & division operation \\
  \hline 
  \texttt{mod} & \textit{Math} & modulo operation \\
  \hline 
  \texttt{join} & Merge & joins multiple operators \\
  \hline 
  \texttt{ejoin} & \textit{ElementMerge} & adds elements to the stream \\
  \hline
  \texttt{split} & \textit{Split} & duplicates a stream \\
  \hline
  \texttt{filter} & \textit{Filter} & filter a stream after a multiple criterias \\
  \hline
  \texttt{tag} & \textit{Tag} & map elements stream/ontology \\
  \hline   
  \texttt{untag} & \textit{Untag} & map elements ontology/stream \\
  \hline 
  \texttt{swrl} &  \textit{SWRL} & operator for specification of SWRL rules \\
  \hline
  \texttt{dtree} & DecisionTree & decision tree \\
  \hline  
  \texttt{sparql} & Tag (Sparql) & specifies sparql queries \\
  \hline 
  \texttt{in} & CacheIn & input operator \\
  \hline
  \texttt{out} & CacheOut & output operator \\
  \hline
  \texttt{rand} & RandomInts & generates random integer values \\
  \hline
  - & PrintOnScreen & prints data on screen \\
  \hline  
  - & SeparateOddEven & operator for modulo two \\
  \hline  
  - & NumberGenerator & operator which generates numbers \\
  \hline  
  \texttt{log} & Log & log operator \\
  \hline
  \end{tabular}
  \captionof{table}{\emph{Comparision of operators in query language and framework}}
  \label{tab:overview}
\end{center}

\subsection{Language}
A comparison of operators in the query language and the corresponding operators 
in LUA is depicted in table \ref{tab:overview}. Operators set in italic are not 
implemented in the DataStreamMiner framework, but will be generated by the 
generator of the query language. For a full description of the operators of the
query language please be referred to \cite{297:Frey2010}. However, important 
changes to the design and behavior of operators is described in the 
corresponding sections.

\subsubsection{Streams}
While streams are the main entities of the query language, the DSM framework 
itself focuses on operators and the interconnection between them. Thus, streams
are set as parameters of an operator where a additional string denotes if it is 
a input or a output stream. Listing \ref{lst:stream} depicts an example where 
two streams \texttt{one} and \texttt{two} are connected to the input and output 
of an operator.
\begin{lstlisting}[language=Lua, caption={\emph{Example of Streams in LUA}},label={lst:stream}]
-- the strings represent the direction
fm:connect_operators(two, "out", one, "in");
\end{lstlisting}
The query language supports multiple streams as a return type, whereas the LUA
interface of the DSM framework only supports multiple streams for operators in
special cases. Hence, the generator of the query language transforms if required
multiple streams into several \texttt{split} operations where streams are 
copied.

\subsubsection{Barriers}
The query language introduced two types of barrier mechanisms 
\cite{297:Frey2010}. The first barrier mechanism provides a sliding window over
a stream of data, whereas the sliding window can be specified in terms of time
(seconds, minutes or hours) or elements. The second barrier mechanism is a 
marker mechanism which provides a special element in a data stream. Elements 
in a stream are processed while a marker passes the operator. For further 
information about the marker barrier mechanism please be referred to 
\cite{297:Frey2010}. Since the DSM framework does not support markers, the 
feature was disabled and might be included in future versions of the language 
and the DSM framework. Listing \ref{lst:exbaflw} shows an example for a barrier
in the average operator \texttt{avg} of the query language.
\begin{lstlisting}[language=Flow, caption={\emph{Example of Barrier Mechanism in Flow}},label={lst:exbaflw}]
// operation computes the average value of an element over the last 10 hours
a = avg(r.element, r[last 10 hrs]);
\end{lstlisting}
The barrier is transformed into the LUA construct depicted in listing 
\ref{lst:exbalua}. The barrier mechanism is transformed into a 
\texttt{set\_parameter()} operation of the operator. The first parameter in line
1 denotes the step size of the sliding window whereas the time is set in 
miliseconds. The last parameter in line 2 sets the type of the sliding window,
here it is \texttt{time}. Another option for the window type is 
\texttt{elements}. At present the \texttt{time} option only supports seconds,
minutes and hours. 
\begin{lstlisting}[language=Lua, caption={\emph{Example of Barrier Mechanism in LUA}},label={lst:exbalua}]
-- step_size_num denotes the step size, window_type the type of the window
a:set_parameter("step_size_num", "36000000");
a:set_parameter("window_type", "time");
\end{lstlisting}

\subsubsection{Operators}
The following section presents examples for operators written in the query 
language and the corresponding  transformation into LUA artifacts. Every 
operator is initialized by a \texttt{create\_operator\_of\_type}() operation. 
Paramters of each operator are set with a \texttt{set\_param\-eter()} operation 
which consists of a key/value structure. The first argument of the operation
denotes the key, the second argument the value of the key. Typically, input and
output streams of different operators are connected by the 
\texttt{connect\_operators()} operation. Parameters of the operation are the 
input and output streams and a string value which denotes the direction of the 
stream. 
\begin{lstlisting}[language=Flow, caption={\emph{Examples of Analysis Operators in Flow}},label={lst:exanflw}]
// Operation: Computes the average of an element 'element' in a stream r over the last 10 hours
a = avg(r.element, r[last 10 hrs]);
// Operation: Computes the standard deviation of an element 'element' in a stream s over the last 20 elements
b = std(s.element, s[last 20 elements]);
// Operation: Counts the occurrence of element 'element' in a stream t in the last 10 minutes
c = count(t.element, t[last 10 min]);
\end{lstlisting}
Analysis operators are average (\texttt{avg}), standard deviation (\texttt{std})
and count (\texttt{count}). Each operator has a parameter which denotes the 
element in a stream while the second parameter defines the sliding window over
the stream. Listing \ref{lst:exanflw} depicts examples for the analysis 
operators. The initialization of the streams is omitted. The operators 
specified in the previous listing are transformed in the corresponding LUA 
artifacts which are depicted in listing \ref{lst:exanlua}. Each operator is 
identified by a name which corresponds to the output stream of the operator. 
The first argument in the initialization of the operator identifies the output
stream of the operator, the second argument specifies the type of the operator. 
\begin{lstlisting}[language=Lua, caption={\emph{Examples of Analysis Operators in LUA}},label={lst:exanlua}]
-- average operator
a = fm:create_operator_of_type("a", "IntAvg");
a:set_parameter("step_size_num", "36000000");
a:set_parameter("window_type", "time");
a:set_parameter("element", "element");
fm:connect_operators(a, "out", r, "in");

-- standard deviation operator
b = fm:create_operator_of_type("b", "StandardDeviation");
b:set_parameter("step_size_num", "20");
b:set_parameter("window_type", "elements");
b:set_parameter("element", "element");
fm:connect_operators(b, "out", s, "in");

-- count operator
c = fm:create_operator_of_type("c", "MessageCounter");
c:set_parameter("step_size_num", "600000");
c:set_parameter("window_type", "time");
c:set_parameter("element", "element");
fm:connect_operators(c, "out", t, "in");
\end{lstlisting}
Arithmetic operators are addition (\texttt{add}), subtraction 
(\texttt{sub}), multiplication (\texttt{mult}), division (\texttt{div}) and
modulo (\texttt{mod}). Parameter of each arithmetic operator is an element in
a stream which represents the left operand of the arithmetic operation and
a right operand which can be a number, variable or another element in a stream. 
The result of each arithmetic operation is a value which is saved in a output
stream. Listing \ref{lst:exarflw} depicts an example for each arithmetic 
operator, whereas listing \ref{lst:exarflw} presents the arithmetic operators 
transformed into LUA artifacts.
\begin{lstlisting}[language=Flow, caption={\emph{Examples of Arithmetic Operators in Flow}},label={lst:exarflw}]
// Operation: d = u.element + 2
d = add(u.element, 2);
// Operation: e = v.element - o
e = sub(v.element, o);
// Operation: f = w.element * x.element
f = mult(w.element, x.element);
// Operation: g = y.element / 3
g = div(y.element, 3);
// Operation: h = a.element % z.element
h = mod(a.element, z.element); 
\end{lstlisting}
Bla
\begin{lstlisting}[language=LUA, caption={\emph{Examples of Arithmetic Operators in LUA}},label={lst:exanlua}]
-- Add
d = fm:create_operator_of_type("d", "Math");
d:set_parameter("operationType", "add");
d:set_parameter("literal", "2");
fm:connect_operators(d, "out", u, "in");
-- Sub
e = fm:create_operator_of_type("e", "Math");
e:set_parameter("operationType", "sub");
e:set_parameter("literal", "42");
fm:connect_operators(e, "out", v, "in");
-- Mult
f = fm:create_operator_of_type("f", "Math");
f:set_parameter("operationType", "mult");
f:set_parameter("stream", "x");
f:set_parameter("element", "element");
fm:connect_operators(f, "out", w, "in0");
fm:connect_operators(f, "out", x, "in1");
-- Div
g = fm:create_operator_of_type("g", "Math");
g:set_parameter("operationType", "div");
g:set_parameter("literal", "3");
fm:connect_operators(g, "out", y, "in");
-- Mod
h = fm:create_operator_of_type("h", "Math");
h:set_parameter("operationType", "mod");
h:set_parameter("stream", "z");
h:set_parameter("element", "element");
fm:connect_operators(h, "out", a, "in0");
fm:connect_operators(h, "out", z, "in1");
\end{lstlisting}
Structural operators are \texttt{join}, \texttt{ejoin} and \texttt{split}. The
following listing \ref{lst:exstructflw} depicts an example for each operation.
\begin{lstlisting}[language=Flow, caption={\emph{Examples of Structural Operators \texttt{join},  \texttt{ejoin} and  \texttt{filter} in Flow}},label={lst:exstructflw}]
// merges the two streams a and b
c = join(a, b);
// adds two elements to a stream b
d = ejoin(newElement, a.element, b);	
// filters stream on the stated condition
e = filter(d.element > 2, d);
\end{lstlisting}
The transformation of the previously presented operators is depicted in listing
\ref{lst:exstructlua}. The \texttt{join} operation specifies two input streams
and one output stream in line three and four. At present, the \texttt{ejoin} 
operator is not supported by the DSM framework. Parameters of the operator are
variables with an assigned value or elements of different streams, which are 
transformed into a set of assignments where the name and type of the element
is set by a \texttt{set\_parameter()} operation. The \texttt{filter} operator
allows to filter a stream by specifying boolean expressions which have to hold
true for a stream. Since no operator for boolean expressions is specified in the
LUA interface of the DSM framework, the expressions are compiled into a set of 
\texttt{set\_parameter()} operations where a expression is transformed to a 
textual representation of each aspect of an expression. This includes type and 
value of an operand as well as the operator of the boolean expression. 
\begin{lstlisting}[language=Lua, caption={\emph{Examples of Structural Operators  \texttt{join},  \texttt{ejoin} and  \texttt{filter} in LUA}},label={lst:exstructlua}]
-- merge (join) operator
c = fm:create_operator_of_type("c", "Merge");
fm:connect_operators(c, "out", a, "in0");
fm:connect_operators(c, "out", b, "in1");
-- element join operation 
d = fm:create_operator_of_type("d", "ElementMerge");
d:set_parameter("name", "newElement");
d:set_parameter("type", "number");
d:set_parameter("value", "2");
d:set_parameter("stream_name", "a");
d:set_parameter("stream_element", "element");
d:set_parameter("stream_element_type", "int");
fm:connect_operators(d, "out", a, "in0");
fm:connect_operators(d, "out", b, "in1");
-- filter operation 
e = fm:create_operator_of_type("e", "Filter");
e:set_parameter("type", ">");
e:set_parameter("operand", "right");
e:set_parameter("datatype", "number");
e:set_parameter("value", "2");
e:set_parameter("operand", "left");
e:set_parameter("stream", "d");
e:set_parameter("element", "element");
fm:connect_operators(e, "out", d, "in");
\end{lstlisting}
Knowledge operators of the query language \texttt{tag}, \texttt{untag} and 
\texttt{sparql}. Listing \ref{lst:knowledgeflw} shows an example for each
knowledge operator. 
\begin{lstlisting}[language=Flow, caption={\emph{Examples of Knowledge Operators in Flow}},label={lst:knowledgeflw}]
// Tag
d = tag(a.element is class "<http://www.semanticweb.org/ontologies/2007/7/A.owl#Class1186574909930821000>", a.anotherElement is class "<http://www.semanticweb.org/ontologies/2007/7/A.owl#Class1186574918251108000>", a);
// UnTag
d = untag("<http://www.semanticweb.org/ontologies/2007/7/A.owl#Class1186574909930821000>" is a.anotherElement, a);
\end{lstlisting}
Listing \ref{lst:knowledgelua} shows the transformation of the knowledge operators
to LUA.
\begin{lstlisting}[language=Lua, caption={\emph{Examples of Knowledge Operators in LUA}},label={lst:knowledgelua}]
-- Tag
e = fm:create_operator_of_type("e", "OperatorTag");
d:set_parameter("owl_class", "<http://www.semanticweb.org/ontologies/2007/7/A.owl#Class1186574909930821000>");
d:set_parameter("element", "element");
d:set_parameter("owl_class", "<http://www.semanticweb.org/ontologies/2007/7/A.owl#Class1186574918251108000>");
d:set_parameter("element", "anotherElement");
fm:connect_operators(e, "out", a, "in");
-- UnTag
d = fm:create_operator_of_type("d", "UnTag");
d:set_parameter("ontology_element", "<http://www.semanticweb.org/ontologies/2007/7/A.owl#Class1186574909930821000>");
d:set_parameter("variable", "anotherElement");
fm:connect_operators(d, "out", a, "in");
\end{lstlisting}
System operators are the input (\texttt{in}), output (\texttt{out}) and log
(\texttt{log}) operator. The input and ouput operators require a single 
internationalized resource identifier (IRI) or a list of IRIs, a address and a 
port. In addition, the output operator requires a input stream. The log operator
requires a location, a format and a input stream. Examples for the system 
operators are shown in listing \ref{lst:exsysflw}.
\begin{lstlisting}[language=Flow, caption={\emph{Examples of System Operators in Flow}},label={lst:exsysflw}]
cacheIn = in("http://www.test.de", "localhost", 9595);
// The location is a file called 'generated3.txt', the format is the file 'aal', input stream is 'dt'
cacheOut = out(cacheIn, "http://www.anothertest.de", "localhost", 9596);
// The location is a file called 'generated3.txt', the format is the file 'aal', input stream is 'dt'
logIn = log("generated3.txt", "aal", dt);
\end{lstlisting}
The transformed operators are depicted in listing \ref{lst:exanlua}, whereas the
input operator is transformed to the \texttt{CacheIn} operator, the output operator 
to the \texttt{CacheOut} and the log operator to the \texttt{Log} operator. Every
parameter of an operator in the query language is transformed to a \texttt{set\_parameter()}
operation in LUA.
\begin{lstlisting}[language=Lua, caption={\emph{Examples of System Operators in LUA}},label={lst:exanlua}]
-- input/cachein operator
cacheIn = fm:create_operator_of_type("cacheIn", "CacheIn");
cacheIn:set_parameter("list_iris", "http://www.anothertest.de ");
cacheIn:set_parameter("connector_socket_address", "localhost");
cacheIn:set_parameter("connector_socket_port", "9595");
-- output/cacheout operator
cacheOut = fm:create_operator_of_type("cacheOut", "CacheOut");
cacheOut:set_parameter("list_iris", "http://www.anothertest.de ");
cacheOut:set_parameter("connector_socket_address", "localhost");
cacheOut:set_parameter("connector_socket_port", "9596");
fm:connect_operators(cacheOut, "out", cacheIn, "in");
-- log operator
logIn = fm:create_operator_of_type("logIn", "Log");
logIn:set_parameter("log_file_location", "generated3.txt");
logIn:set_parameter("log_format", "aal");
fm:connect_operators(logIn, "out", dt, "in");
\end{lstlisting}

\subsection{Deprecated Features of the Query Language}
Operators and language features which were part of previous version of the query
language are denoted in table \ref{tab:deprecated}. The expressivness of a query
language is limited to the system on which the language is executed.

The transformation of procedural statements to a data stream mining system
has its limitations. Typically, such a system can be intepreted as a acyclic 
directed graph, where edges can be intepreted as streams and vertices as 
operators. Control structures such as loops violate the acyclic property of a 
acyclic directed graph. Conditional structurs such as 
if/else or switch statements can be expressed by means of the \texttt{filter}
operator and therefore are syntactic sugar. 
\begin{center}
  \begin{tabular}{|l|l|l|}
  \hline
  \textbf{Feature} & \textbf{Type} & \textbf{Comment} \\
  \hline
  \hline
  \texttt{map} & Operator & Operator for projections \\
  \hline
  marker & Operator & Mechanism for creating flexible barriers \\
  \hline
  \texttt{match} & Operator & Operator which compared two streams depending on a expression \\
  \hline
  \texttt{dif} & Operator & Operator for creating differences in sets (set theory) \\
  \hline
  \texttt{sdif} & Operator & Operator for creating symmetric differences in sets (set theory) \\
  \hline
  loops & Feature & Loop statements such as while  \\
  \hline
  conditions & Feature & Conditional statements such as if/else or switch/case \\
  \hline
  functions & Feature & Procedural functions for the map operator \\
  \hline
  \end{tabular}
  \captionof{table}{\emph{Deprecated features of the query language}}
  \label{tab:deprecated}
\end{center}

\subsection{Integration of Meta-models}
Xtext allows to reference instances of metamodels within a DSL. In order to use 
this mechanism several steps are required. The integration of OWL is used as an
example for the illustration of the integration process. Several steps are 
required in order to integrate a external metamodel into a Xtext DSL. First, the
metamodel must be referenced in the grammar of the language which is depicted in
listing \ref{lst:import}. In order to reference elements of the metamodel a 
unique identifier is assigned, here \texttt{owl}.
\begin{lstlisting}[language=Xtext, caption={\emph{Integration of the OWL ecore model into a grammar}},label={lst:import}]
import "platform:/resource/de.hs_rm.cs.vs.dsm.flow/model/owl.ecore"
   as owl
\end{lstlisting}
Second, the metamodel needs to be referecend in the MWE2 workflow of the main 
language plug-in. Listing \ref{lst:importmwe} shows how to register the
genmodel of the OWL metamodel in the MWE2 workflow definition of the query 
language.
\begin{lstlisting}[language=MWE2, caption={\emph{Integration of the OWL ecore model into a MWE2 workflow}},label={lst:importmwe}]
Workflow {
  bean = StandaloneSetup {
  ...
  platformUri = "${runtimeProject}/.."
    registerGenModelFile = "platform:/resource/de.hs_rm.cs.vs.dsm.flow/model/owl.genmodel"
\end{lstlisting}

\subsection{Summary}
